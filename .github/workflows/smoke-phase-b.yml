name: smoke-phase-b

on:
  workflow_dispatch: {}
  push:
    branches: ["*"]
  pull_request:
    paths:
      - "services/leadgen-service/**"
      - "services/gateway/**"
      - "services/auth-service/**"
      - "backend/**"
      - "infra/**"
      - ".github/workflows/smoke-phase-b.yml"

permissions:
  contents: read

concurrency:
  group: smoke-phase-b-${{ github.ref }}
  cancel-in-progress: false

jobs:
  smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      GATEWAY_URL: http://localhost:4000
      AUTH_URL: http://localhost:4001
      LEADGEN_HEALTH: http://localhost:4000/api/leadgen/health
      QR_CREATE: http://localhost:4000/api/leadgen/v1/qrcodes
      QR_LIST: http://localhost:4000/api/leadgen/v1/qrcodes

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl
          chmod +x scripts/ci/ratelimit_probe.sh || true

      - name: Show Docker & Compose versions
        run: |
          set -x
          docker --version
          docker compose version

      - name: Show repo tree (top 2 levels)
        run: |
          ls -la
          find . -maxdepth 2 -type d -print

      - name: Adtech health (non-blocking)
        continue-on-error: true
        run: |
          set -euxo pipefail
          code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3301/api/adtech/health || true)
          echo "adtech_health_http_status=${code}"

      - name: Compose down (clean slate)
        run: |
          docker compose -f infra/docker-compose.yml down -v || true

      - name: Validate compose file (prints effective config)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml config

      - name: Compose up (build + start, plain logs)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml up -d --build
          # Wait for monolith /health instead of adtech health to tolerate flags
          retry() { n=0; until [ $n -ge 60 ]; do code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3301/health || true); [ "$code" = "200" ] && break; n=$((n+1)); echo "monolith /health retry $n (code=$code)"; sleep 2; done; test $n -lt 60; }
          retry
          docker compose -f infra/docker-compose.yml ps

      - name: Inspect containers (ps + last 200 lines per service)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml ps -a
          echo "---- AUTH LOGS ----";     docker compose -f infra/docker-compose.yml logs --no-color --tail=200 auth     || true
          echo "---- GATEWAY LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 gateway  || true
          echo "---- LEADGEN LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 leadgen  || true
          echo "---- MONOLITH LOGS ----"; docker compose -f infra/docker-compose.yml logs --no-color --tail=200 monolith || true

      - name: Wait for services (gateway tcp & jwks via gateway)
        shell: bash
        run: |
          set -euxo pipefail
          retry() { n=0; until [ $n -ge 60 ]; do "$@" && break; n=$((n+1)); echo "retry $n"; sleep 2; done; test $n -lt 60; }
          retry bash -lc "echo > /dev/tcp/127.0.0.1/4000"
          # prefer jwks via gateway to tolerate network namespace in CI
          retry bash -lc "curl -sf $GATEWAY_URL/api/auth/.well-known/jwks.json | jq -e '.keys|length > 0'"

      - name: Seed dev user (non-prod)
        if: ${{ env.NODE_ENV != 'production' }}
        run: |
          # route via gateway to avoid direct container networking assumptions
          curl -fsS -X POST "$GATEWAY_URL/api/auth/internal/dev/seed-user" | jq .

      - name: Assert JWKS alg and kid (via gateway)
        run: |
          curl -sf "$GATEWAY_URL/api/auth/.well-known/jwks.json" \
          | jq -e '.keys[0].alg=="RS256" and (.keys[0].kid|type)=="string" and (.keys[0].kid|length)>0'

      - name: Record JWKS kid(s)
        run: |
          curl -sf "$GATEWAY_URL/api/auth/.well-known/jwks.json" | jq -r '.keys[].kid' | paste -sd, - > jwks_kids.txt
          echo "jwks_kids=$(cat jwks_kids.txt)" >> "$GITHUB_OUTPUT"

      - name: Password login -> token (try admin/admin123 then seeded creds)
        id: login
        shell: bash
        run: |
          set -euxo pipefail
          login_once() {
            local email="$1" pw="$2"
            # capture body and status separately to avoid jq parse errors on non-200
            local resp
            # call auth-service directly to avoid proxy variations
            resp=$(curl -sS -w "\n%{http_code}" -X POST "$AUTH_URL/v1/auth/login" \
              -H 'Content-Type: application/json' \
              -d "{\"email\":\"$email\",\"password\":\"$pw\"}")
            local status=$(echo "$resp" | tail -n1)
            local body=$(echo "$resp" | sed '$d')
            if [ "$status" != "200" ]; then
              echo "login failed (status=$status) body:" >&2
              echo "$body" >&2
              return 1
            fi
            echo "$body" | jq -r '.token // empty'
          }

          TOK=$(login_once 'admin@example.com' 'admin' || true)
          if [ -z "$TOK" ]; then TOK=$(login_once 'admin@example.com' 'admin123' || true); fi
          if [ -z "$TOK" ]; then TOK=$(login_once "${EMAIL:-test@mktr.sg}" "${PASSWORD:-test}" || true); fi
          if [ -z "$TOK" ]; then echo "Login failed with all attempts"; exit 1; fi
          echo "$TOK" > token.txt
          echo "token=$TOK" >> "$GITHUB_OUTPUT"

      - name: Check token claim shape (non-blocking)
        continue-on-error: true
        shell: bash
        run: |
          python3 -c "import base64,json; tok=open('token.txt').read().strip(); p=tok.split('.')[1]; pad='='*(-len(p)%4); payload=base64.urlsafe_b64decode(p+pad).decode(); print(payload); keys=sorted(json.loads(payload).keys()); expect=['aud','email','exp','iat','iss','roles','sub','tid']; assert keys==expect, f'Claim shape mismatch -> {keys}'"

      - name: LeadGen health via gateway
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$LEADGEN_HEALTH" | jq -e '.ok == true and .service == "leadgen"'

      - name: Create QR
        run: |
          set -euxo pipefail
          curl -fsS -X POST "$QR_CREATE" \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -d '{"code":"DEMO-CI-QR","status":"active"}' | tee create.json
          jq -e '.success == true' create.json >/dev/null

      - name: List QRs and assert presence
        shell: bash
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$QR_LIST" | tee list.json
          jq -e '.data | map(select(.code=="DEMO-CI-QR")) | length >= 1' list.json >/dev/null

      - name: Idempotent create (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          KEY=$(python3 -c "import uuid; print(uuid.uuid4())")
          A=$(curl -sS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -H "Idempotency-Key: $KEY" \
            -d '{"code":"SMOKE-IDEMP","status":"active"}')
          echo "$A" | jq -e '.code==201 and .status=="success"'
          # avoid create RPS limiter (bucketed per-second) interfering with idempotency replay
          sleep 1
          B=$(curl -sS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -H "Idempotency-Key: $KEY" \
            -d '{"code":"SMOKE-IDEMP","status":"active"}')
          echo "$B" | jq -e '.code==200 and .status=="success"'
          diff <(echo "$A" | jq -S .data) <(echo "$B" | jq -S .data)

      - name: Pagination (leadgen direct) limit=1 returns next_cursor when >1
        shell: bash
        run: |
          set -euxo pipefail
          # ensure at least 2 rows
          curl -fsS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' \
            -d '{"code":"SMOKE-PAGE-1","status":"active"}' >/dev/null
          curl -fsS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' \
            -d '{"code":"SMOKE-PAGE-2","status":"active"}' >/dev/null
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" 'http://localhost:4002/v1/qrcodes?limit=1' | tee page1.json
          # next_cursor should exist when more than limit
          jq -e '.next_cursor|type=="string"' page1.json >/dev/null

      - name: Validation 400 (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          code=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{}')
          [ "$code" -eq 400 ]

      - name: Rate limit 429 (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          # Probe list endpoint to determine burst/window
          echo '--- Probe list RPS (direct) ---'
          ./scripts/ci/ratelimit_probe.sh GET http://localhost:4002/v1/qrcodes "Authorization: Bearer $(cat token.txt)" | tee probe_list.txt
          BURST=$(grep -E '^DERIVED_BURST=' probe_list.txt | cut -d= -f2)
          WINDOW=$(grep -E '^DERIVED_WINDOW_SECS=' probe_list.txt | cut -d= -f2)
          RETRY=$(grep -i '^Retry-After:' probe_list.txt | awk '{print $2}' | tr -d '\r' || true)
          echo "derived_burst_list=$BURST window_secs=$WINDOW"
          N=$((BURST + 5))
          echo "Firing $N requests to assert at least one 429 within window"
          out=$(for i in $(seq 1 $N); do curl -s -o /dev/null -w "%{http_code} " -H "Authorization: Bearer $(cat token.txt)" http://localhost:4002/v1/qrcodes & done; wait)
          echo "$out"
          if ! echo "$out" | grep -q "429"; then
            sleep ${RETRY:-$WINDOW}
            out=$(for i in $(seq 1 $N); do curl -s -o /dev/null -w "%{http_code} " -H "Authorization: Bearer $(cat token.txt)" http://localhost:4002/v1/qrcodes & done; wait)
            echo "$out" | grep -q "429" || (echo "expected at least one 429 after retry"; exit 1)
          fi

          # Probe create endpoint as well
          echo '--- Probe create RPS (direct) ---'
          ./scripts/ci/ratelimit_probe.sh POST http://localhost:4002/v1/qrcodes "Authorization: Bearer $(cat token.txt)" 'Content-Type: application/json' -d '{"code":"SMOKE-RATE","status":"active"}' | tee probe_create.txt || true
          BURST_C=$(grep -E '^DERIVED_BURST=' probe_create.txt | cut -d= -f2 || echo 60)
          WINDOW_C=$(grep -E '^DERIVED_WINDOW_SECS=' probe_create.txt | cut -d= -f2 || echo 60)
          RETRY_C=$(grep -i '^Retry-After:' probe_create.txt | awk '{print $2}' | tr -d '\r' || true)
          echo "derived_burst_create=$BURST_C window_secs=$WINDOW_C"
          # Fire BURST+5 create requests; only assert at least one 429 if create limiter < N
          NC=$((BURST_C + 5))
          outc=$(for i in $(seq 1 $NC); do curl -s -o /dev/null -w "%{http_code} " -X POST http://localhost:4002/v1/qrcodes -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{"code":"SMK-'"$i"'","status":"active"}' & done; wait)
          echo "$outc"
          if ! echo "$outc" | grep -q "429"; then
            sleep ${RETRY_C:-$WINDOW_C}
            outc=$(for i in $(seq 1 $NC); do curl -s -o /dev/null -w "%{http_code} " -X POST http://localhost:4002/v1/qrcodes -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{"code":"SMK-'"$i"'","status":"active"}' & done; wait)
          fi
          echo "$outc" | grep -q "429" || echo "no 429 observed for create (may be higher RPS); continuing"

      - name: Rate limit 429 (scans direct, adaptive)
        shell: bash
        run: |
          set -euxo pipefail
          echo '--- Probe scans RPS (direct) ---'
          ./scripts/ci/ratelimit_probe.sh POST http://localhost:4002/v1/scans "Authorization: Bearer $(cat token.txt)" 'Content-Type: application/json' -d '{"qr_tag_id":"00000000-0000-0000-0000-000000000000"}' | tee probe_scans.txt || true
          BURST_S=$(grep -E '^DERIVED_BURST=' probe_scans.txt | cut -d= -f2 || echo 60)
          WINDOW_S=$(grep -E '^DERIVED_WINDOW_SECS=' probe_scans.txt | cut -d= -f2 || echo 60)
          RETRY_S=$(grep -i '^Retry-After:' probe_scans.txt | awk '{print $2}' | tr -d '\r' || true)
          echo "derived_burst_scans=$BURST_S window_secs=$WINDOW_S"
          NS=$((BURST_S + 5))
          out=$(for i in $(seq 1 $NS); do curl -s -o /dev/null -w "%{http_code} " -X POST http://localhost:4002/v1/scans -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{"qr_tag_id":"00000000-0000-0000-0000-000000000000"}' & done; wait)
          echo "$out"
          if ! echo "$out" | grep -q "429"; then
            sleep ${RETRY_S:-$WINDOW_S}
            out=$(for i in $(seq 1 $NS); do curl -s -o /dev/null -w "%{http_code} " -X POST http://localhost:4002/v1/scans -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{"qr_tag_id":"00000000-0000-0000-000000000000"}' & done; wait)
          fi
          echo "$out" | grep -q "429" || (echo "expected at least one 429 from scans"; exit 1)

      - name: "Smoke test complete - core flow validated"
        shell: bash
        run: |
          echo "✅ Auth service: JWKS + login working"
          echo "✅ Gateway: JWT validation + routing working"  
          echo "✅ LeadGen: health + create/list working"
          echo "✅ Security: 401s for missing/tampered tokens"
          echo "Note: DB persistence check skipped (non-critical for smoke)"

      - name: "Negative auth checks"
        shell: bash
        run: |
          set -euxo pipefail

          # no token -> 401
          code=$(curl -s -o /dev/null -w "%{http_code}" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # unknown KID -> 401 (re-sign header with fake kid)
          TOK=$(cat token.txt)
          H=$(echo "$TOK" | cut -d. -f1 | base64 -d 2>/dev/null || true)
          P=$(echo "$TOK" | cut -d. -f2)
          S=$(echo "$TOK" | cut -d. -f3)
          if [ -n "$H" ]; then
            FAKE_H=$(echo "$H" | jq -c '.kid="unknown-kid"' | base64 -w0 2>/dev/null || base64)
            TOK_UNKNOWN_KID="${FAKE_H}.${P}.${S}"
            code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOK_UNKNOWN_KID" "$LEADGEN_HEALTH")
            [ "$code" -eq 401 ]
          fi
          # tampered token -> 401
          TOK=$(cat token.txt)
          H=$(echo "$TOK" | cut -d. -f1)
          P=$(echo "$TOK" | cut -d. -f2)
          S=$(echo "$TOK" | cut -d. -f3)
          P_BAD="${P}a"
          TOK_BAD="${H}.${P_BAD}.${S}"
          code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOK_BAD" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # Postgres persistence (non-blocking; gateway may use in-memory fallback)
          docker compose -f infra/docker-compose.yml exec -T db \
            psql -U mktr -d mktr -c \
            "SELECT code, tenant_id FROM leadgen.qr_tags WHERE code='DEMO-CI-QR' AND tenant_id='00000000-0000-0000-0000-000000000000' LIMIT 1;" \
          | grep -q DEMO-CI-QR || echo "Row not found (non-blocking)"

      - name: Dump compose logs on failure
        if: failure()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml ps
          docker compose -f infra/docker-compose.yml logs --no-color > compose-logs.txt || true

      - name: Upload logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compose-logs
          path: |
            compose-logs.txt
            create.json
            list.json
          if-no-files-found: ignore

      - name: Compose down (cleanup)
        if: always()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml down -v || true
