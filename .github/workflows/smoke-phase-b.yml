name: smoke-phase-b

on:
  workflow_dispatch: {}
  pull_request:
    paths:
      - "services/leadgen-service/**"
      - "services/gateway/**"
      - "services/auth-service/**"
      - "backend/**"
      - "infra/**"
      - ".github/workflows/smoke-phase-b.yml"

permissions:
  contents: read

concurrency:
  group: smoke-phase-b-${{ github.ref }}
  cancel-in-progress: false

jobs:
  smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      GATEWAY_URL: http://localhost:4000
      AUTH_URL: http://localhost:4001
      LEADGEN_HEALTH: http://localhost:4000/api/leadgen/health
      QR_CREATE: http://localhost:4000/api/leadgen/v1/qrcodes
      QR_LIST: http://localhost:4000/api/leadgen/v1/qrcodes

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Show Docker & Compose versions
        run: |
          set -x
          docker --version
          docker compose version

      - name: Show repo tree (top 2 levels)
        run: |
          ls -la
          find . -maxdepth 2 -type d -print

      - name: Compose down (clean slate)
        run: |
          docker compose -f infra/docker-compose.yml down -v || true

      - name: Validate compose file (prints effective config)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml config

      - name: Compose up (build + start, plain logs)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml up -d --build
          docker compose -f infra/docker-compose.yml ps

      - name: Inspect containers (ps + last 200 lines per service)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml ps -a
          echo "---- AUTH LOGS ----";     docker compose -f infra/docker-compose.yml logs --no-color --tail=200 auth     || true
          echo "---- GATEWAY LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 gateway  || true
          echo "---- LEADGEN LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 leadgen  || true
          echo "---- MONOLITH LOGS ----"; docker compose -f infra/docker-compose.yml logs --no-color --tail=200 monolith || true

      - name: Wait for services (gateway tcp & jwks via gateway)
        shell: bash
        run: |
          set -euxo pipefail
          retry() { n=0; until [ $n -ge 60 ]; do "$@" && break; n=$((n+1)); echo "retry $n"; sleep 2; done; test $n -lt 60; }
          retry bash -lc "echo > /dev/tcp/127.0.0.1/4000"
          # prefer jwks via gateway to tolerate network namespace in CI
          retry bash -lc "curl -sf $GATEWAY_URL/api/auth/.well-known/jwks.json | jq -e '.keys|length > 0'"

      - name: Seed dev user (non-prod)
        if: ${{ env.NODE_ENV != 'production' }}
        run: |
          # route via gateway to avoid direct container networking assumptions
          curl -fsS -X POST "$GATEWAY_URL/api/auth/internal/dev/seed-user" | jq .

      - name: Assert JWKS alg and kid (via gateway)
        run: |
          curl -sf "$GATEWAY_URL/api/auth/.well-known/jwks.json" \
          | jq -e '.keys[0].alg=="RS256" and (.keys[0].kid|type)=="string" and (.keys[0].kid|length)>0'

      - name: Password login -> token (try admin/admin123 then seeded creds)
        id: login
        shell: bash
        run: |
          set -euxo pipefail
          login_once() {
            local email="$1" pw="$2"
            # capture body and status separately to avoid jq parse errors on non-200
            local resp
            resp=$(curl -sS -w "\n%{http_code}" -X POST "$GATEWAY_URL/api/auth/v1/auth/login" \
              -H 'Content-Type: application/json' \
              -d "{\"email\":\"$email\",\"password\":\"$pw\"}")
            local status=$(echo "$resp" | tail -n1)
            local body=$(echo "$resp" | sed '$d')
            echo "http_status=$status"
            if [ "$status" != "200" ]; then
              echo "login failed (status=$status) body:" >&2
              echo "$body" >&2
              echo ""; return 1
            fi
            echo "$body" | jq -r '.token // empty'
          }

          TOK=$(login_once 'admin@example.com' 'admin' || true)
          if [ -z "$TOK" ]; then TOK=$(login_once 'admin@example.com' 'admin123' || true); fi
          if [ -z "$TOK" ]; then TOK=$(login_once "${EMAIL:-test@mktr.sg}" "${PASSWORD:-test}" || true); fi
          if [ -z "$TOK" ]; then echo "Login failed with all attempts"; exit 1; fi
          echo "$TOK" > token.txt
          echo "token=$TOK" >> "$GITHUB_OUTPUT"

      - name: Check token claim shape (non-blocking)
        continue-on-error: true
        shell: bash
        run: |
          python3 -c "import base64,json; tok=open('token.txt').read().strip(); p=tok.split('.')[1]; pad='='*(-len(p)%4); payload=base64.urlsafe_b64decode(p+pad).decode(); print(payload); keys=sorted(json.loads(payload).keys()); expect=['aud','email','exp','iss','roles','sub','tid']; assert keys==expect, f'Claim shape mismatch -> {keys}'"

      - name: LeadGen health via gateway
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$LEADGEN_HEALTH" | jq -e '.ok == true and .service == "leadgen"'

      - name: Create QR
        run: |
          set -euxo pipefail
          curl -fsS -X POST "$QR_CREATE" \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -d '{"code":"DEMO-CI-QR","status":"active"}' | tee create.json
          jq -e '.success == true' create.json >/dev/null

      - name: List QRs and assert presence
        shell: bash
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$QR_LIST" | tee list.json
          jq -e '.data | map(select(.code=="DEMO-CI-QR")) | length >= 1' list.json >/dev/null

      - name: "Negative auth checks + Postgres assert"
        shell: bash
        run: |
          set -euxo pipefail

          # no token -> 401
          code=$(curl -s -o /dev/null -w "%{http_code}" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # tampered token -> 401
          TOK=$(cat token.txt)
          H=$(echo "$TOK" | cut -d. -f1)
          P=$(echo "$TOK" | cut -d. -f2)
          S=$(echo "$TOK" | cut -d. -f3)
          P_BAD="${P}a"
          TOK_BAD="${H}.${P_BAD}.${S}"
          code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOK_BAD" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # Postgres persistence
          docker compose -f infra/docker-compose.yml exec -T db \
            psql -U mktr -d mktr -c \
            "SELECT code, tenant_id FROM leadgen.qrcodes WHERE code='DEMO-CI-QR' AND tenant_id='00000000-0000-0000-0000-000000000000' LIMIT 1;" \
          | grep -q DEMO-CI-QR

      - name: Dump compose logs on failure
        if: failure()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml ps
          docker compose -f infra/docker-compose.yml logs --no-color > compose-logs.txt || true

      - name: Upload logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compose-logs
          path: |
            compose-logs.txt
            create.json
            list.json
          if-no-files-found: ignore

      - name: Compose down (cleanup)
        if: always()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml down -v || true
