name: smoke-phase-b

on:
  workflow_dispatch: {}
  pull_request:
    paths:
      - "services/leadgen-service/**"
      - "services/gateway/**"
      - "services/auth-service/**"
      - "backend/**"
      - "infra/**"
      - ".github/workflows/smoke-phase-b.yml"

permissions:
  contents: read

concurrency:
  group: smoke-phase-b-${{ github.ref }}
  cancel-in-progress: false

jobs:
  smoke:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    env:
      GATEWAY_URL: http://localhost:4000
      AUTH_URL: http://localhost:4001
      LEADGEN_HEALTH: http://localhost:4000/api/leadgen/health
      QR_CREATE: http://localhost:4000/api/leadgen/v1/qrcodes
      QR_LIST: http://localhost:4000/api/leadgen/v1/qrcodes

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Show Docker & Compose versions
        run: |
          set -x
          docker --version
          docker compose version

      - name: Show repo tree (top 2 levels)
        run: |
          ls -la
          find . -maxdepth 2 -type d -print

      - name: Adtech health (non-blocking)
        continue-on-error: true
        run: |
          set -euxo pipefail
          code=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3301/api/adtech/health || true)
          echo "adtech_health_http_status=${code}"

      - name: Compose down (clean slate)
        run: |
          docker compose -f infra/docker-compose.yml down -v || true

      - name: Validate compose file (prints effective config)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml config

      - name: Compose up (build + start, plain logs)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml up -d --build
          docker compose -f infra/docker-compose.yml ps

      - name: Inspect containers (ps + last 200 lines per service)
        run: |
          set -euxo pipefail
          docker compose -f infra/docker-compose.yml ps -a
          echo "---- AUTH LOGS ----";     docker compose -f infra/docker-compose.yml logs --no-color --tail=200 auth     || true
          echo "---- GATEWAY LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 gateway  || true
          echo "---- LEADGEN LOGS ----";  docker compose -f infra/docker-compose.yml logs --no-color --tail=200 leadgen  || true
          echo "---- MONOLITH LOGS ----"; docker compose -f infra/docker-compose.yml logs --no-color --tail=200 monolith || true

      - name: Wait for services (gateway tcp & jwks via gateway)
        shell: bash
        run: |
          set -euxo pipefail
          retry() { n=0; until [ $n -ge 60 ]; do "$@" && break; n=$((n+1)); echo "retry $n"; sleep 2; done; test $n -lt 60; }
          retry bash -lc "echo > /dev/tcp/127.0.0.1/4000"
          # prefer jwks via gateway to tolerate network namespace in CI
          retry bash -lc "curl -sf $GATEWAY_URL/api/auth/.well-known/jwks.json | jq -e '.keys|length > 0'"

      - name: Seed dev user (non-prod)
        if: ${{ env.NODE_ENV != 'production' }}
        run: |
          # route via gateway to avoid direct container networking assumptions
          curl -fsS -X POST "$GATEWAY_URL/api/auth/internal/dev/seed-user" | jq .

      - name: Assert JWKS alg and kid (via gateway)
        run: |
          curl -sf "$GATEWAY_URL/api/auth/.well-known/jwks.json" \
          | jq -e '.keys[0].alg=="RS256" and (.keys[0].kid|type)=="string" and (.keys[0].kid|length)>0'

      - name: Record JWKS kid(s)
        run: |
          curl -sf "$GATEWAY_URL/api/auth/.well-known/jwks.json" | jq -r '.keys[].kid' | paste -sd, - > jwks_kids.txt
          echo "jwks_kids=$(cat jwks_kids.txt)" >> "$GITHUB_OUTPUT"

      - name: Password login -> token (try admin/admin123 then seeded creds)
        id: login
        shell: bash
        run: |
          set -euxo pipefail
          login_once() {
            local email="$1" pw="$2"
            # capture body and status separately to avoid jq parse errors on non-200
            local resp
            # call auth-service directly to avoid proxy variations
            resp=$(curl -sS -w "\n%{http_code}" -X POST "$AUTH_URL/v1/auth/login" \
              -H 'Content-Type: application/json' \
              -d "{\"email\":\"$email\",\"password\":\"$pw\"}")
            local status=$(echo "$resp" | tail -n1)
            local body=$(echo "$resp" | sed '$d')
            if [ "$status" != "200" ]; then
              echo "login failed (status=$status) body:" >&2
              echo "$body" >&2
              return 1
            fi
            echo "$body" | jq -r '.token // empty'
          }

          TOK=$(login_once 'admin@example.com' 'admin' || true)
          if [ -z "$TOK" ]; then TOK=$(login_once 'admin@example.com' 'admin123' || true); fi
          if [ -z "$TOK" ]; then TOK=$(login_once "${EMAIL:-test@mktr.sg}" "${PASSWORD:-test}" || true); fi
          if [ -z "$TOK" ]; then echo "Login failed with all attempts"; exit 1; fi
          echo "$TOK" > token.txt
          echo "token=$TOK" >> "$GITHUB_OUTPUT"

      - name: Check token claim shape (non-blocking)
        continue-on-error: true
        shell: bash
        run: |
          python3 -c "import base64,json; tok=open('token.txt').read().strip(); p=tok.split('.')[1]; pad='='*(-len(p)%4); payload=base64.urlsafe_b64decode(p+pad).decode(); print(payload); keys=sorted(json.loads(payload).keys()); expect=['aud','email','exp','iat','iss','roles','sub','tid']; assert keys==expect, f'Claim shape mismatch -> {keys}'"

      - name: LeadGen health via gateway
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$LEADGEN_HEALTH" | jq -e '.ok == true and .service == "leadgen"'

      - name: Create QR
        run: |
          set -euxo pipefail
          curl -fsS -X POST "$QR_CREATE" \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -d '{"code":"DEMO-CI-QR","status":"active"}' | tee create.json
          jq -e '.success == true' create.json >/dev/null

      - name: List QRs and assert presence
        shell: bash
        run: |
          set -euxo pipefail
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" "$QR_LIST" | tee list.json
          jq -e '.data | map(select(.code=="DEMO-CI-QR")) | length >= 1' list.json >/dev/null

      - name: Idempotent create (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          KEY=$(python3 - <<'PY'
import uuid; print(str(uuid.uuid4()))
PY
)
          A=$(curl -sS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -H "Idempotency-Key: $KEY" \
            -d '{"code":"SMOKE-IDEMP","status":"active"}')
          echo "$A" | jq -e '.code==201 and .status=="success"'
          B=$(curl -sS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" \
            -H 'Content-Type: application/json' \
            -H "Idempotency-Key: $KEY" \
            -d '{"code":"SMOKE-IDEMP","status":"active"}')
          echo "$B" | jq -e '.code==200 and .status=="success"'
          diff <(echo "$A" | jq -S .data) <(echo "$B" | jq -S .data)

      - name: Pagination (leadgen direct) limit=1 returns next_cursor when >1
        shell: bash
        run: |
          set -euxo pipefail
          # ensure at least 2 rows
          curl -fsS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' \
            -d '{"code":"SMOKE-PAGE-1","status":"active"}' >/dev/null
          curl -fsS -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' \
            -d '{"code":"SMOKE-PAGE-2","status":"active"}' >/dev/null
          curl -fsS -H "Authorization: Bearer $(cat token.txt)" 'http://localhost:4002/v1/qrcodes?limit=1' | tee page1.json
          # next_cursor should exist when more than limit
          jq -e '.next_cursor|type=="string"' page1.json >/dev/null

      - name: Validation 400 (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          code=$(curl -s -o /dev/null -w "%{http_code}" -X POST http://localhost:4002/v1/qrcodes \
            -H "Authorization: Bearer $(cat token.txt)" -H 'Content-Type: application/json' -d '{}')
          [ "$code" -eq 400 ]

      - name: Rate limit 429 (leadgen direct)
        shell: bash
        run: |
          set -euxo pipefail
          # with compose env LEADGEN_RPS_LIST=1, a quick burst should yield a 429
          code1=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $(cat token.txt)" http://localhost:4002/v1/qrcodes)
          code2=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $(cat token.txt)" http://localhost:4002/v1/qrcodes)
          echo "$code1 $code2"
          [ "$code2" -eq 429 ] || [ "$code1" -eq 429 ]

      - name: "Smoke test complete - core flow validated"
        shell: bash
        run: |
          echo "✅ Auth service: JWKS + login working"
          echo "✅ Gateway: JWT validation + routing working"  
          echo "✅ LeadGen: health + create/list working"
          echo "✅ Security: 401s for missing/tampered tokens"
          echo "Note: DB persistence check skipped (non-critical for smoke)"

      - name: "Negative auth checks"
        shell: bash
        run: |
          set -euxo pipefail

          # no token -> 401
          code=$(curl -s -o /dev/null -w "%{http_code}" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # unknown KID -> 401 (re-sign header with fake kid)
          TOK=$(cat token.txt)
          H=$(echo "$TOK" | cut -d. -f1 | base64 -d 2>/dev/null || true)
          P=$(echo "$TOK" | cut -d. -f2)
          S=$(echo "$TOK" | cut -d. -f3)
          if [ -n "$H" ]; then
            FAKE_H=$(echo "$H" | jq -c '.kid="unknown-kid"' | base64 -w0 2>/dev/null || base64)
            TOK_UNKNOWN_KID="${FAKE_H}.${P}.${S}"
            code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOK_UNKNOWN_KID" "$LEADGEN_HEALTH")
            [ "$code" -eq 401 ]
          fi
          # tampered token -> 401
          TOK=$(cat token.txt)
          H=$(echo "$TOK" | cut -d. -f1)
          P=$(echo "$TOK" | cut -d. -f2)
          S=$(echo "$TOK" | cut -d. -f3)
          P_BAD="${P}a"
          TOK_BAD="${H}.${P_BAD}.${S}"
          code=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Bearer $TOK_BAD" "$LEADGEN_HEALTH")
          [ "$code" -eq 401 ]

          # Postgres persistence (non-blocking; gateway may use in-memory fallback)
          docker compose -f infra/docker-compose.yml exec -T db \
            psql -U mktr -d mktr -c \
            "SELECT code, tenant_id FROM leadgen.qr_tags WHERE code='DEMO-CI-QR' AND tenant_id='00000000-0000-0000-0000-000000000000' LIMIT 1;" \
          | grep -q DEMO-CI-QR || echo "Row not found (non-blocking)"

      - name: Dump compose logs on failure
        if: failure()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml ps
          docker compose -f infra/docker-compose.yml logs --no-color > compose-logs.txt || true

      - name: Upload logs (always)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compose-logs
          path: |
            compose-logs.txt
            create.json
            list.json
          if-no-files-found: ignore

      - name: Compose down (cleanup)
        if: always()
        shell: bash
        run: |
          docker compose -f infra/docker-compose.yml down -v || true
